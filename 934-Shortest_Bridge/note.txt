这是我刷到的第二道题，总的来说应该算是一道比较简单的算法题（虽然花费了很长时间orz。。。）
此题共提交了6次，除去一次解答出错和重复提交，共提交4次，分别代表了四种思路。
总的思路是首先将两座岛分开，然后寻找两岛间的最短路径。分开两岛思路比较简单，采用典型的寻找连通图的算法dfs，关键在于第二步的最短路径。
first：
思路还是dfs，对于岛1的每一个边界，通过dfs遍历找到到岛2边界的最短距离。结果正确，但耗时最慢。
second:
鉴于第一次提交超时的问题，通过性能分析得知主要耗时工作在于寻找最短路径，于是考虑可能是进行了过多的vector创建和赋值操作导致性能下降，去掉了这些耗时工作后运行时间较之前有一定改善，但仍然超时。
third:
于是考虑算法问题。考虑了多源最短路径算法floyd算法，用以替代之前的dfs。运行时间明显改善，但仍然超时，最后最后执行的测试用例用时1秒。
forth:
经过充分思考，认定之前的问题主要在于对整个空余地块进行了多次遍历，而实际情况是只需考虑两岛之间的空隙即可。于是设计了带有动态规划思想的bfs，从岛1边界开始层层外推直到首次达到岛2的边界为止。最终运行时间大幅度改善，使用上一次的测试用例运行时间为12ms。提交后运行时间击败了34.43% 的用户，故仍有很大的改进空间。