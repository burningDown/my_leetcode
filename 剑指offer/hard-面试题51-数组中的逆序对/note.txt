第一直觉便是遍历，时间复杂度O(n2)，如果数不是太大的话一般会满足要求，但测试用例中专门有几个是卡O(n2)的，所以这种方法行不通。

曾经想过要用动态规划，但想不到如何可虑状态转移方程，所以行不通。

查看题解后，发现了一种很好的思路——归并排序。
	问题的关键在于找到逆序的两数，所以只需考虑这两个数的相对位置而不需要考虑在这两者之间的数与它们的位置关系，所以可以采用归并排序，在归并操作时因为经过递归归并故当前数组的左右两部分分别有序，如果当前归并数位于右半部分，则可认为该数在这个数组中的逆序数是左指针到左半部分结束的数的总数，因为这些数一定大于当前归并数。