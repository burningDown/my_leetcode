刚开始想采用bfs方法，即当前丑数分别乘2、3、5后进入队列然后从队列中提取第一个数再次循环这个过程，但发现按这个顺序排出的丑数并不严格有序，于是想到每次从队列中选取一个最小值，于是想到了小根堆，C++中可用一个优先队列表示。时间复杂度O(nlogn)。

看题解后发现我的方法已经非常接近官方思路了。实际上每次入队列我们都希望加入当前的最小值，考虑之前遇到的双指针思路就非常适合这种场景。这里有三个前进方向，故需要三个指针，分别表示2，3，5的前进方向，另外还需要一个数组来存储已计算过的丑数，然后让这三个指针指向数组中的数，表示2，3，5因子的乘数，然后依次递增即可。