这题我的想法是跟之前做过的一道交换字符位置让字符串符合条件的题类似，但要简单的多，首先遍历整个字符串统计所有字母的频数，然后取一个计数变量count，然后再次遍历整个字符串，根据是否首次遍历和频数是否为零决定count ++还是--，并输出count为时的子串长度。

不过官方的题解给出的是贪心算法，即统计每个字母最后一次出现的位置，然后遍历字符串找到当前子串中最远的最后位置，则到此为止为一个子串。显然这个方法更优。