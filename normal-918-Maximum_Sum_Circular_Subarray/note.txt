先考虑暴力法，即将A向后连接形成一个逻辑上的AA数组，然后从0到l-1分别开始遍历执行一次最大子串和算法（Kadane 算法），毫无疑问超时；

对于最大串位于A数组内和分为左右两段的情况可分开考虑：
	对于第一种情况可直接执行最大字串和算法；
	对于第二种情况，可分别计算每个位置的最大前缀和和最大后缀和并分别存入数组，然后由0到l-1遍历求对应前缀和后缀和的和并取最大值。

官方题解还提到Kadane 算法的变种：先求最小子串和，然后将A数组所有元素和减掉这个最小子串和，即从A数组中抠掉一段连续的和为最小值的子串，则剩下的部分前后拼接后将形成最大和子串。