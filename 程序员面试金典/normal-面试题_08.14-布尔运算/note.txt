拿到这题，首先考虑到，要遍历出所有的结合顺序，所以可以进行一个递归过程：
	1. 对于当前字符串s，遍历计算相邻两数的逻辑运算结果；
	2. 然后将原两数的表达式替换为计算结果，并递归这个过程；
	3. 若s的长度为1，则当前s保存的是这条路径最终的运算结果，判断其是否与result相等，并返回结果。
运行测试用例后发现上述过程存在重复考虑的结合方式，例如(a&b)*(c&d)这样的表达式会被重复记两次。


上述思路是一种由下向上结合的过程，现考虑另一种思路，即由上至下：针对表达式中任意一个运算符，可将运算符的左右两部分看作一个整体，即(...)|(...)这样，然后用分治思想分别再递归处理表达式左右两边的子表达式，子表达式可有多种结果，例如左边的表达式值为0和值为1有不同的结合方式，此时根据当前划分表达式的运算符确定不同的结合方式，例如对于&运算符，若result为1，则仅有1&1的情况，若result为0则有1&0、0&1、0&0三种情况，则当前划分下的结合方式总数为左右子表达式结合数的乘积。

但上述分治法思想若直接递归会超时，于是考虑优化为动态规划。


要注意的是，对于动态规划，除了考虑状态转移方程外，还要考虑状态的更新顺序。若状态更新顺序难以第一时间想到的话，可以考虑一种较为简单的实现：记忆化搜索。

所谓记忆化搜索，当我们在递归分治求解的时候一个很大的问题是许多确定的状态会在不同的状态组合下被重复计算多次从而成为造成时间消耗过大的罪魁祸首，那么我们可以直接定义一个dp表来保存分治求解的结果，当后续计算再一次到达当前状态的时候先查找dp表，发现当前状态已经被计算过，则可以直接返回该值，从而避免大量的重复计算，其本质也是动态规划。