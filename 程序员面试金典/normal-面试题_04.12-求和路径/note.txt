直接想法是直接回溯遍历，然后记录当前路径所有子段和，每遍历一次判断一下当前是否存在与sum相等的路径和，显然效率不高，有大量重复计算。


当然查看题解后发现提到的方法正是我开始也想过的一种思路，只是我不清楚具体要如何操作：
	思路大体同上，只是维护一个map，然后只记录当前路径总长度，即当前节点到根节点的长度，统计个数，然后用currentSum - sum的值查map，如果存在值res则表示有当前有res条子路径的和为sum。
		因为 currentSum - preSum = sum, 可推出 cuurentSum - sum = preSum。