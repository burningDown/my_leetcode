这题遇到过好几次了，用回溯，但我采用的回溯方法是维护一个visited，然后每次遍历S找到没有被处理过的字符再进行下一次回溯。

当然我自知这样效率不高，但考虑到这种全排列的测试用例一般不会太长所以影响也不会很大。查看题解后找到了一种效率更高的方法，这也是我最开始在做这种题的时候的思路：
	对于每次回溯的当前字符，分别将该字符与其后的所有字符交换顺序，后进行下一次回溯。