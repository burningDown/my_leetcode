回溯：显而易见的是，因为合并一组石头后会产生新的石头序列，然后可以再次执行这个过程，故而形成一个递归过程，然后采用回溯遍历所有的合并路径。显然会超时

区间动态规划：换一种思路，假设当前需要合并K个石头，那么这K个石头的每一个也一定是经过0次以上的合并操作形成的，然后K个合并各自独立，于是这K个数的和为最小值时其各自的K个数也一定是各自的最小值，于是产生一个动态规划过程：
	1. 欲将当前区间[l, r]合并为一个，首先保证该区间经过若干次K合并后一定可以合并为1个数，这一点可以在合并遍历的时候设定遍历步长和规则来实现；
	2. 然后将[l, r]区间内的所有数合并为K个数，这个问题可以分割为：
		2.1 首先将[l, i]区间合并为1个数（l<=i<=r-k-2，r-k-2意义在于保证剩余区间长度大于K-1）
		2.2 然后剩余[i+1, r]合并为K-1个数，于是要保证该区间长度一定大于K-1
		2.3 重复这个过程，直到产生K个数
	3. 将[l, r]合并后的K个数合并为1个数，并加上合并成本sum(stones[l ... r])
	4. 根据2.1中的i遍历，取2.3中K个数和的最小值