总的来说，这道题要解决的问题是如何在保证最小顺序的情况下去除重复字母。
可以类比数的大小比较：如有两个位数相同的大数67543和67521比较大小，首先从最高位开始依次向低位遍历两数并比较大小，直到找到第一个不相等的位为止。即两数的大小仅取决于不相等的最高位的大小。
于是本题也是这样的思路：从第一位开始，选择属于该位的最小的字符，直到遍历完。

最开始我的思路：
	首先统计字符串s中所有字符的出现频率；
	遍历字符串s，
		若当前字符c出现频率为1，则当前位置一定是该字符；
		若当前字符c频率大于1，则表示改字符可能被换掉，是否要换掉要取决于下一个不动字符的大小；
			而下一个字符是否保留又取决于下下个字符的大小，于是形成一个递归过程；
			直到遇到第一个不动字符，则回溯整个递归过程来确定所有不确定字符是否保留。
	直到遍历完，输出所有不动字符为最终结果。

	这种思路在当前字符与不动字符不同的时候一定可以解决，但问题出在若两字符相等则无法确定应该舍掉哪个，如abacb。

之后：
	如abacb，以第1个a开头的串和以第3个a开头的串需要单独比较，这样联想到“八皇后问题”，我想到了回溯法。
	（具体思路见图）
	这样思路没有问题，但问题在于该思路难以用C++实现（并非无法实现，只是需要占用较大的资源，效率一定不高）。

通用做法：
	普遍的做法是贪心。
	遍历字符串s，在满足当前字符c在待定结果中按栈顺序为最大值的条件下，将当前字符加入待定结果，暂且认定当前字符满足要求；
	直到遍历完，按队列顺序输出待定结果。